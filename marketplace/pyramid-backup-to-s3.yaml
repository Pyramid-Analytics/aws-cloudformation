AWSTemplateFormatVersion: 2010-09-09
Description: >-
  Backs up a Pyramid Marketplace CloudFormation deployment (stack) - repository database and EFS file systems - to S3.
  This stack can be deleted afterwards, as the S3 bucket is retained.
Metadata:
  'AWS::CloudFormation::Interface':
    ParameterGroups:
      - Label:
          default: Backup configuration
        Parameters:
          - BaseStackName
          - BucketName
          - BucketFolder
      - Label:
          default: Instance configuration
        Parameters:
          - LatestAmiId
          - Subnet
          - KeyPairName
          - RunOnce
    ParameterLabels:
      BucketName:
        default: Bucket to backup to. Optional - if left blank, a new bucket will be created.
      BucketFolder:
        default: Optional. Folder within bucket to backup to. Date-timestamp folder will be created under this.
      BaseStackName:
        default: Base Stack of the Pyramid deployment to be backed up
      KeyPairName:
        default: Key pair name
      LatestAmiId:
        default: Latest Amazon Linux 2 AMI
      Subnet:
        default: Subnet within the deployment VPC to run the instance in
      RunOnce:
        default: Run backup and stop
Parameters:
  LatestAmiId:
    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'
    Default: '/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-ebs'
    Description: SSM Parameter for Latest Amazon Linux 2 AMI
  BaseStackName:
    Description: Base StackName to backup
    Type: String
    MinLength: '1'
    MaxLength: '32'
    AllowedPattern: '[-_a-zA-Z0-9]*'
    ConstraintDescription: Required
  BucketName:
    Description: Bucket to backup to
    Type: String
    Default: ''
    MaxLength: '64'
    AllowedPattern: '[-a-z0-9]*'
    ConstraintDescription: Optional. If entered, requires lowercase alphanumeric and '-'
  BucketFolder:
    Description: Folder within bucket to backup to. Date-timestamp folder will be created under this.
    Type: String
    MaxLength: '64'
    AllowedPattern: '[-_a-zA-Z0-9/=]*'
    ConstraintDescription: Optional
  RunOnce:
    Description: >-
      Run the instance start scripts and stop.
    Type: String
    Default: true
    AllowedValues:
      - true
      - false
    ConstraintDescription: Required
  KeyPairName:
    Description: >-
      Name of an existing EC2 key pair, which allows you to securely connect to
      your instance after it launches.
    Type: 'AWS::EC2::KeyPair::KeyName'
    ConstraintDescription: Required
  Subnet:
    Description: >-
      Subnet within the VPC of the Pyramid deployment to run the instance
    Type: 'AWS::EC2::Subnet::Id'
    ConstraintDescription: Required
Rules:
  KeyPairsNotEmpty:
    Assertions:
      - Assert: !Not 
          - 'Fn::EachMemberEquals':
              - 'Fn::RefAll': 'AWS::EC2::KeyPair::KeyName'
              - ''
        AssertDescription: All key pair parameters must not be empty
Conditions:
  CreateS3Bucket: !Equals
   - !Ref BucketName
   - ''
  IncludeBucketFolder: !Not
    - !Equals
      - !Ref BucketFolder
      - ''
  TerminateInstance: !Equals
   - !Ref RunOnce
   - 'true'
Resources:
  InstanceWaitHandle:
    Type: 'AWS::CloudFormation::WaitConditionHandle'
  InstanceWaitCondition:
    Type: 'AWS::CloudFormation::WaitCondition'
    Properties:
      Handle: !Ref InstanceWaitHandle
      # 5 mins
      Timeout: '300'
      Count: 1

  NowFunc:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: >
          var r = require('cfn-response');
          var m = new Date();
          var dateString =
              m.getUTCFullYear() + "-" +
              ("0" + (m.getUTCMonth()+1)).slice(-2) + "-" +
              ("0" + m.getUTCDate()).slice(-2) + "-" +
              ("0" + m.getUTCHours()).slice(-2) + "-" +
              ("0" + m.getUTCMinutes()).slice(-2) + "-" +
              ("0" + m.getUTCSeconds()).slice(-2);
          exports.handler = function(ev, ctx) {
            ev.ResourceProperties.Time = dateString;
            r.send(ev, ctx, r.SUCCESS, ev.ResourceProperties);
          }; 
      Handler: index.handler
      Runtime: nodejs12.x
      Timeout: 30
      Role: !GetAtt NowFunctionExecutionRole.Arn

  NowFunctionExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal: { Service: [ lambda.amazonaws.com ] }
            Action: sts:AssumeRole
      Policies:
        - PolicyName: 
            Fn::Sub: "now-custom-res-${AWS::StackName}-${AWS::Region}"
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "arn:aws:logs:*:*:*"
              - Effect: Allow
                Action: cloudformation:DescribeStacks
                Resource: "arn:aws:cloudformation:*:*:*"

  GetTimeThisTime:
    Type: Custom::Value
    Properties:
      ServiceToken: !GetAtt NowFunc.Arn

  S3Bucket:
    Type: 'AWS::S3::Bucket'
    Condition: CreateS3Bucket
    Properties:
      AccessControl: BucketOwnerFullControl
    DeletionPolicy: Retain

  BackupManagedPolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Properties:
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: S3
            Effect: Allow
            Action:
              - 's3:*'
            Resource:
              - !Join
                - ''
                - - 'arn:'
                  - !Ref 'AWS::Partition'
                  - ':s3:::'
                  - !If
                    - CreateS3Bucket
                    - !Ref S3Bucket
                    - !Ref BucketName
                  - '/*'
              - !Join
                - ''
                - - 'arn:'
                  - !Ref 'AWS::Partition'
                  - ':s3:::'
                  - !If
                    - CreateS3Bucket
                    - !Ref S3Bucket
                    - !Ref BucketName
          - Sid: SSMGetParameters
            Effect: Allow
            Action:
              - 'ssm:GetParameters'
              - 'ssm:GetParametersByPath'
            Resource:
              - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/Pyramid/${BaseStackName}/*'
              - !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/Pyramid/${BaseStackName}'
      Roles:
        - !Sub '{{resolve:ssm:/Pyramid/${BaseStackName}/PyramidRole:1}}'

  BackupInstance:
    Type: 'AWS::EC2::Instance'
    DependsOn: BackupManagedPolicy
    Metadata:
      'AWS::CloudFormation::Init':
        configSets:
          default:
            - EnableAmazonLinuxExtraPackages
            - 01_setupCfnHup
            - 02_config-amazon-cloudwatch-agent
            - 03_restart_amazon-cloudwatch-agent
            - BackupPyramid
          UpdateEnvironment:
            - 02_config-amazon-cloudwatch-agent
            - 03_restart_amazon-cloudwatch-agent

        EnableAmazonLinuxExtraPackages:
          packages:
            yum:
              amazon-efs-utils: []
              amazon-cloudwatch-agent: []
          commands:
            enable_amazon-linux-extras_packages:
              command: "amazon-linux-extras enable epel postgresql10 && yum clean metadata"

        # Cfn-hup setting, it is to monitor the change of metadata.
        # When there is change in the contents of json file in the metadata section, cfn-hup will call cfn-init to restart the AmazonCloudWatchAgent.
        01_setupCfnHup:
          files:
            '/etc/cfn/cfn-hup.conf':
              content: !Sub |
                [main]
                stack=${AWS::StackId}
                region=${AWS::Region}
                interval=1
              mode: '000400'
              owner: root
              group: root
            '/etc/cfn/hooks.d/amazon-cloudwatch-agent-auto-reloader.conf':
              content: !Sub |
                [cfn-auto-reloader-hook]
                triggers=post.update
                path=Resources.PyramidInstance.Metadata.AWS::CloudFormation::Init.02_config-amazon-cloudwatch-agent
                action=/opt/aws/bin/cfn-init -v --stack ${AWS::StackId} --resource BackupInstance--region ${AWS::Region} --configsets UpdateEnvironment
                runas=root
              mode: '000400'
              owner: root
              group: root
            "/lib/systemd/system/cfn-hup.service":
              content: |
                [Unit]
                Description=cfn-hup daemon
                [Service]
                Type=simple
                ExecStart=/opt/aws/bin/cfn-hup
                Restart=always
                [Install]
                WantedBy=multi-user.target
          commands:
            01enable_cfn_hup:
              command: systemctl enable cfn-hup.service
            02start_cfn_hup:
              command: systemctl start cfn-hup.service

        # Definition of json configuration of AmazonCloudWatchAgent
        02_config-amazon-cloudwatch-agent:
          files:
            /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json:
              content: !Sub |
                {
                  "logs": {
                    "logs_collected": {
                      "files": {
                        "collect_list": [
                          {
                            "file_path": "/var/log/cfn-init.log",
                            "log_group_name": "/pyramid/${BaseStackName}",
                            "log_stream_name": "{instance_id}-backup/cf-init",
                            "timestamp_format": "%Y-%m-%d %H:%M:%S,%f"
                          }
                        ]
                      }
                    }
                  }
                }
        # Invoke amazon-cloudwatch-agent-ctl to restart the AmazonCloudWatchAgent.
        03_restart_amazon-cloudwatch-agent:
          commands:
            01_stop_service:
              command: /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a stop
            02_start_service:
              command: /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -c file:/opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json -s

        BackupPyramid:
          packages:
            yum:
              # installed with EFS
              # nfs-utils: []
              postgresql: []
              
          files:
            /usr/src/pyramid/mnt-efs.sh:
              content: |
                #!/bin/bash
                #
                # Set up an EFS mount on an instance.
                #
                # Create the mount target if one has not been created for
                # the AZ the subnet is attached to.
                # 
                # Create the  --mountPoint <mount point directory> and mount an Elastic File
                # System (EFS) id --efsId <EFS ID> to it.
                #
                # Parameters:
                # efsId=${efsId}
                # mountPoint=${mountPoint:-/mnt/pyramid}
                # subnet
                # securityGroup
                # region
                #
                # So minimal use is:
                # mnt-efs.sh \
                #   --efsId fs-24334234 \
                #   --subnet subnet-055fb67972f8052d2 \
                #   --securityGroup sg-0667a5ea299a0e03c \
                #   --region us-east-1
                ##
                # This script can only run on an AWS instance. It must run as root, and be
                # invoked at instance startup: cf-init, user data
                #
                
                set -o errexit

                # ----------------------------------------------------------------------------
                # Set and validate parameters
                # ----------------------------------------------------------------------------

                efsId=${efsId}
                mountPoint=${mountPoint:-/mnt/pyramid}
                subnet=
                securityGroup=
                region=

                wait_for_mount_target_availability() {
                  local mountTarget=${1}
                  local region=${2}

                  echo "Waiting for mount target $mountTarget to be available"
                  local maxTimes=30
                  local sleepTime=10
                  local count=0
                  local notificationCount=5
                  while true
                  do
                    describeMT=`aws efs describe-mount-targets --mount-target-id $mountTarget --region $region --output text`
                    mt_status=$( echo "$describeMT" | cut -f 6 )
                    if [ "${mt_status}" = "available" ] ; then
                      break
                    fi
                    count=$(( count + 1  ))
                    if [ "$count" -ge "$maxTimes" ] ; then
                      echo "Mount target status is $mt_status. Did not become available after ${maxTimes} tries, waiting ${sleepTime} seconds between tries... Exiting"
                      return 1
                    elif  ! (( count % notificationCount )) ; then
                      echo "Mount target status is $mt_status ...continuing to wait"
                    fi
                    sleep $sleepTime
                  done
                  echo "Mount target $mountTarget is available"
                  return 0
                }

                create_mount_target() {
                  local efsId=${1}
                  local subnet=${2}
                  local securityGroup=${3}
                  local region=${4}

                  # Subnet AZ
                  subnetAZ=`aws ec2 describe-subnets --subnet-ids $subnet --region $region --output text | grep '^SUBNETS' | cut -f 3` || return 1
                  local foundAZ=1

                  allMountTargets=`aws efs describe-mount-targets --file-system-id $efsId --region $region --output text`
                  if [ $? -ne 0 ] ; then
                    return 1
                  fi
                  while read line ; do
                    az=$( echo "$line" | cut -f 3 )
                    mt_status=$( echo "$line" | cut -f 6 )
                    mountTarget=$( echo "$line" | cut -f 7 )
                    if [ "${az}" = "${subnetAZ}" ] ; then
                      if [ "${mt_status}" != 'available' ] ; then
                        wait_for_mount_target_availability $mountTarget $region
                        if [ $? -ne 0 ] ; then
                          return 1
                        fi
                      fi
                      foundAZ=0
                      break
                    fi
                  done <<< "$allMountTargets"

                  if [ $foundAZ = 0 ]; then
                    echo "Mount target for $efsId in $subnetAZ already existed"
                    return 0
                  fi
                  echo "About to create mount target for file system: $efsId in AZ: $subnetAZ"
                  newMountTargetResult=`aws efs create-mount-target \
                      --file-system-id $efsId \
                      --subnet-id $subnet \
                      --security-groups $securityGroup \
                      --region $region \
                      --output text`
                  if [ $? -ne 0 ] ; then
                    echo "create-mount-target failed"
                    return 1
                  fi
                  mt_id=$( echo "$newMountTargetResult" | cut -f 6 )

                  wait_for_mount_target_availability $mt_id $region
                  return $?
                }


                ##########################################
                # main script

                while [ $# -gt 0 ]; do
                  if [[ $1 == *"--"* ]]; then
                    param="${1/--/}"
                    declare $param="$2"
                    echo $1 $2 # Optional: to see the parameter:value result
                    shift
                  fi
                  shift
                done

                if [[ -z "${efsId}" ]] ; then
                  echo "efsId not set"
                  exit 1
                fi

                if [[ -z "${subnet}" ]] ; then
                  echo "subnet not set"
                  exit 1
                fi

                if [[ -z "${securityGroup}" ]] ; then
                  echo "securityGroup not set"
                  exit 1
                fi

                if [[ -z "${region}" ]] ; then
                  echo "region not set"
                  exit 1
                fi
                
                # ----------------------------------------------------------------------------
                # Create mount point directory
                # ----------------------------------------------------------------------------
                # if the mountPoint directory does not exist
                if [ ! -d "${mountPoint}" ] ; then
                  mkdir -p "${mountPoint}"
                else
                  # fail if the mountPoint already exists
                  echo "mountPoint directory ${mountPoint} already exists. exiting..."
                  exit 1
                fi

                # create a mount target group if needed
                create_mount_target $efsId $subnet $securityGroup $region
                if [ $? -ne 0 ] ; then
                echo "create_mount_target failed"
                exit 1
                fi

                echo "About to mount $efsId to $mountPoint"

                # Mount the EFS volume using the AWS EFS helper
                # IAM is used for authentication to EFS
                sleepTime=20
                maxTimes=40
                notificationCount=5
                count=0
                while true
                do
                  mount -t efs -o tls,iam $efsId $mountPoint && break
                  count=$(( count + 1  ))
                  if [ "$count" -ge "$maxTimes" ] ; then
                    echo "Mount did not succeed after ${maxTimes} tries, waiting ${sleepTime} seconds between tries... Exiting"
                    exit 1
                  elif  ! (( count % notificationCount )) ; then
                      echo "Mount did not succeed ...continuing to wait"
                  fi
                  sleep $sleepTime
                done

                echo "Mounted EFS $efsId to $mountPoint"

              mode: '000755'
              owner: root
              group: root


            /usr/src/pyramid/backup-to-s3:
              content: |
                #!/bin/bash
                label=$1
                baseStackName=$2
                subnet=$3
                region=$4
                bucketName=$5
                bucketFolder=${6:-}

                set -o errexit

                mtSecurityGroup=`aws ssm get-parameter --name "/Pyramid/$baseStackName/MountTargetSecurityGroup" --region $region --output text | cut -f 7`
                sharedFileSystemEFS=`aws ssm get-parameter --name "/Pyramid/$baseStackName/SharedFileSystem" --region $region --output text | cut -f 7`

                /usr/src/pyramid/mnt-efs.sh \
                    --subnet $subnet \
                    --securityGroup $mtSecurityGroup \
                    --efsId $sharedFileSystemEFS \
                    --region $region

                rdsAddress=`aws ssm get-parameter --name "/Pyramid/$baseStackName/RepositoryDatabaseAddress" --region $region --output text | cut -f 7`
                rdsPort=`aws ssm get-parameter --name "/Pyramid/$baseStackName/RepositoryDatabasePort" --region $region --output text | cut -f 7`
                rdsName=`aws ssm get-parameter --name "/Pyramid/$baseStackName/RepositoryDatabaseName" --region $region --output text | cut -f 7`
                rdsUsername=`aws ssm get-parameter --name "/Pyramid/$baseStackName/RepositoryDatabaseUsername" --region $region --output text | cut -f 7`

                rdsPassword=`aws secretsmanager get-secret-value --secret-id /Pyramid/$baseStackName/RepositoryDatabasePassword --region $region --output text | cut -f 4`

                if [ ! -d /mnt/pyramid/repoBackup ] ; then
                  mkdir -p /mnt/pyramid/repoBackup
                fi
                echo "backing up $rdsName on service $rdsAddress"
                # dump the repository into the shared file system
                export PGPASSWORD=$rdsPassword
                pg_dump -F c -U $rdsUsername -h $rdsAddress -p $rdsPort $rdsName > "/mnt/pyramid/repoBackup/$baseStackName-repository-$label.dump"

                # catch the 2020-13 release approach of having an EFS volume per IMDB
                # dump each IMDB file system to s3
                ssmParams=`aws ssm get-parameters-by-path --path "/Pyramid/$baseStackName" --recursive --region $region --output text`
                # looking for SSM parameters of the forms:
                #    '/Pyramid/$baseStackName/${AWS::StackName}/IMDBFileSystem'
                while read line ; do
                  # name is cut -f 1
                  name=`echo $line | cut -d " " -f 5`
                  endPortion=`echo $name | cut -d '/' -f 5`

                  # echo "<$name> **** <$endPortion>"
                  if [[ "${endPortion}" == "IMDBFileSystem" ]] ; then
                    # value is cut -f 3
                    fileSystemId=`echo $line | cut -d " " -f 7`
                    # echo "fileSystemId - $fileSystemId"
                    /usr/src/pyramid/mnt-efs.sh \
                      --mountPoint /mnt/pyramid-imdb/$fileSystemId \
                      --subnet $subnet \
                      --securityGroup $mtSecurityGroup \
                      --efsId $fileSystemId \
                      --region $region

                    mkdir -p /mnt/pyramid/imdb/$fileSystemId
                    echo "copying $fileSystemId to $sharedFileSystemEFS /imdb/$fileSystemId"
                    # cp -p -R /mnt/pyramid-imdb/$fileSystemId/. /mnt/pyramid/imdb/$fileSystemId
                    # --remove-source-files \
                    rsync \
                      --chown=pyramid:pyramid \
                      /mnt/pyramid-imdb/$fileSystemId /mnt/pyramid/imdb/$fileSystemId
                    umount /mnt/pyramid-imdb/$fileSystemId
                    rm -rf /mnt/pyramid-imdb/$fileSystemId
                  fi
                done <<< "$ssmParams"

                # deal with an EFS volume without a /shared directory
                if [ ! -d /mnt/pyramid/shared ] ; then
                  mkdir /mnt/pyramid/shared
                  find /mnt/pyramid/ -type f -maxdepth 1  -exec cp -t /mnt/pyramid/shared/ {} +
                fi

                if [ ! -z "${bucketFolder}"] ; then
                  s3Destination="s3://$bucketName/$bucketFolder/$label"
                else
                  s3Destination="s3://$bucketName/$label"
                fi
                echo "Synching to $s3Destination"
                # dump EFS to s3
                aws s3 sync --no-progress /mnt/pyramid/shared $s3Destination/shared
                aws s3 sync --no-progress /mnt/pyramid/imdb $s3Destination/imdb
                aws s3 sync --no-progress /mnt/pyramid/repoBackup $s3Destination/repoBackup

                # remove the repo dump from the
                rm -rf /mnt/pyramid/repoBackup/$baseStackName-repository-$label.dump
                umount /mnt/pyramid
                rm -rf /mnt/pyramid

              mode: '000755'
              owner: root
              group: root
          commands:
            1-execute-backup:
              # backup-to-s3 \
              #   2020-11-13-15-00-00 \
              #   Pyr-v8 \
              #   subnet-01892aa0ff74872e0 \
              #   us-east-1 \
              #   pyr-v8-backup-s3bucket-17f7k5buabvbh
              command: !Join
                - ' '
                - - /usr/src/pyramid/backup-to-s3
                  - !GetAtt GetTimeThisTime.Time
                  - !Sub '${BaseStackName}'
                  - !Sub '${Subnet}'
                  - !Sub '${AWS::Region}'
                  - !If
                    - CreateS3Bucket
                    - !Ref S3Bucket
                    - !Ref BucketName
                  - !If
                    - IncludeBucketFolder
                    - !Ref BucketFolder
                    - !Ref AWS::NoValue
              ignoreErrors: 'false'

    Properties:
      ImageId: !Ref LatestAmiId
      KeyName: !Sub '{{resolve:ssm:/Pyramid/${BaseStackName}/KeyPairName:1}}'
      IamInstanceProfile: !Sub '{{resolve:ssm:/Pyramid/${BaseStackName}/PyramidInstanceProfile:1}}'
      InstanceType: t3.medium
      SecurityGroupIds:
        - !Sub '{{resolve:ssm:/Pyramid/${BaseStackName}/PyramidProcessesSecurityGroup:1}}'
        - !Sub '{{resolve:ssm:/Pyramid/${BaseStackName}/MountTargetSecurityGroup:1}}'
      SubnetId: !Ref Subnet
      InstanceInitiatedShutdownBehavior: !If
        - TerminateInstance
        - terminate
        - stop
      Monitoring: false
      DisableApiTermination: false
      BlockDeviceMappings:
        - DeviceName: "/dev/sda1"
          Ebs: 
            VolumeSize: 8
      UserData: !Base64
        'Fn::Join':
          - ''
          - - |
              Content-Type: multipart/mixed; boundary="//"
              MIME-Version: 1.0
              --//
              Content-Type: text/cloud-config; charset="us-ascii"
              MIME-Version: 1.0
              Content-Transfer-Encoding: 7bit
              Content-Disposition: attachment; filename="cloud-config.txt"
              #cloud-config
              cloud_final_modules:
              [scripts-user, always]
              --//
              Content-Type: text/x-shellscript; charset="us-ascii"
              MIME-Version: 1.0
              Content-Transfer-Encoding: 7bit
              Content-Disposition: attachment; filename="userdata.txt"
              #!/bin/bash -xe

              # run cfn-init
            - |+

            - '/opt/aws/bin/cfn-init -v  --configsets default --stack '
            - !Ref 'AWS::StackName'
            - ' --resource BackupInstance --region '
            - !Ref 'AWS::Region'
            - |+

            - |
              # Signal the status from cfn-init

            - '/opt/aws/bin/cfn-signal -e $? '
            - !Base64
              Ref: InstanceWaitHandle
            - |+

            - |
              # If asked, halt and catch fire

            - 'if [ '''
            - !Ref RunOnce
            - ''' = ''true'' ] ; then /sbin/halt -p; fi'
            - |+

            - ''
            - |+

      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}'
        - Key: Vendor
          Value: Pyramid
        - Key: StackName
          Value: !Sub '${BaseStackName}'
        - Key: Contents
          Value: Backup

Outputs:
  BackupBucket:
    Description: Backup S3 Bucket
    Value: !If
      - CreateS3Bucket
      - !Ref S3Bucket
      - !Ref BucketName

  BackupPath:
    Description: S3 backup path
    Value: !Join
      - ''
      - - !If
          - CreateS3Bucket
          - !Ref S3Bucket
          - !Ref BucketName
        - !If
          - IncludeBucketFolder
          - !Sub "/${BucketFolder}/"
          - '/'
        - !GetAtt GetTimeThisTime.Time

