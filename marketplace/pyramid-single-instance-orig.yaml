AWSTemplateFormatVersion: 2010-09-09
Description: >-
  This workload template deploys a single instance of selected Pyramid processes.
  You will be billed for the AWS resources used if you create a stack from this template. 
Metadata:
  'AWS::CloudFormation::Interface':
    ParameterGroups:
      - Label:
          default: Instance configuration
        Parameters:
          - AMIID
          - Subnet
          - InstanceType
          - KeyPairName
          - WorkloadSecurityGroups
          - PyramidRole
          - PyramidInstanceProfile
          - AssignPublicIP
          - InstallProxy
      - Label:
          default: Pyramid instance configuration
        Parameters:
          - BaseStackName
          - PyramidProcess
          - InstancePurpose
          - InitialUsername
          - InitialUserPassword
          - SharedFileSystemId
          - MountTargetSecurityGroup
          - IMDBFileSystemOption
          - RunOnce
          - BackupS3BucketAndFolder
      - Label:
          default: Repository Database configuration
        Parameters:
          - RepositoryType
          - RDSAddress
          - RDSPort
          - RDSUser
          - RDSPassword
          - RDSName
    ParameterLabels:
      BaseStackName:
        default: Base Stack this stack is a part of
      PyramidProcess:
        default: Pyramid processes to run
      InstancePurpose:
        default: Note on this instance's purpose
      KeyPairName:
        default: Key pair name
      WorkloadSecurityGroups:
        default: Security Groups for instances
      PyramidInstanceProfile:
        default: IamInstanceProfile for instance
      PyramidRole:
        default: IamRole for instance
      AMIID:
        default: Pyramid AMI Id
      Subnet:
        default: Subnet to run the instance in
      AssignPublicIP:
        default: Assign public IP and domain name
      RepositoryType:
        default: Using existing repository database, or creating new one
      RDSAddress:
        default: RDS database address
      RDSPort:
        default: RDS database port
      RDSUser:
        default: RDS database user name
      RDSPassword:
        default: RDS database password
      RDSName:
        default: RDS database name
      InitialUsername:
        default: Initial Pyramid user name
      InitialUserPassword:
        default: Initial Pyramid User password
      InstanceType:
        default: Cluster instance type
      MountTargetSecurityGroup:
        default: Security Group for EFS access
      RunOnce:
        default: Run once and terminate
      BackupS3BucketAndFolder:
        default: S3 bucket and optional path to a Pyramid backup
      InstallProxy:
        default: Install nginx as a proxy to the Pyramid web server
      SharedFileSystemId:
        default: EFS Id for the deployment's shared file system
      IMDBFileSystemOption:
        default: Position of IMDB file system
      # IMDBExternalFileSystemId:
      #   default: EFS Id for existing file system
Parameters:
  PyramidProcess:
    Description: >-
      For unattended installation.
    Type: String
    AllowedValues:
      - Everything
      - Router
      - WebServer
      - WebServerAndRouter
      - RuntimeEngine
      - TaskEngine
      - RuntimeEngineAndTaskEngine
      - RuntimeEngineAndAI
      - TaskEngineAndAI
      - RuntimeAndTaskEngineAndAI
      - AIServer
      - InMemoryDB
      - Nothing
    Default: Everything
  BaseStackName:
    Description: Base StackName this stack is a part of
    Type: String
    MinLength: '1'
    MaxLength: '32'
    AllowedPattern: '[-_a-zA-Z0-9]*'
    ConstraintDescription: Required
  InstancePurpose:
    Description: Free text note indicating instance's purpose.
    Type: String
    MinLength: '1'
    MaxLength: '32'
    AllowedPattern: '[-_a-zA-Z0-9]*'
    ConstraintDescription: Required
  AMIID:
    Description: AMI ID of the Pyramid AWS Workplace listing. Usually passed in from another template.
    Type: AWS::EC2::Image::Id
    ConstraintDescription: Required
  PyramidInstanceProfile:
    Description: IamInstanceProfile ID for instance.
    Type: String
    MinLength: '1'
    ConstraintDescription: Required
  PyramidRole:
    Description: IamIRole ID for instance.
    Type: String
    MinLength: '1'
    ConstraintDescription: Required
  MountTargetSecurityGroup:
    Description: For In-Memory EFS access.
    Type: String
    MinLength: '1'
    ConstraintDescription: Required
  WorkloadSecurityGroups:
    Description: >-
      Security groups shared between Pyramid processes
    Type: CommaDelimitedList
    ConstraintDescription: Required
  RunOnce:
    Description: >-
      Run the instance start scripts and terminate.
    Type: String
    Default: false
    AllowedValues:
      - true
      - false
    ConstraintDescription: Required
  BackupS3BucketAndFolder:
    Description: >-
      S3 path to a Pyramid backup
    Type: String
    MaxLength: '1000'
    AllowedPattern: '^$|(?=^.{5,1000}$)[a-zA-Z][-_a-zA-Z0-9/\=()]*$'
    ConstraintDescription: >-
      Optional. Otherwise min 5 characters. First character must be a letter. Must contain only letters, digits, '/', '-', '_', '=', '*' or parentheses.
  InstallProxy:
    Description: >-
      Install nginx as a proxy to the Pyramid web server.
    Type: String
    Default: false
    AllowedValues:
      - true
      - false
    ConstraintDescription: Required
  KeyPairName:
    Description: >-
      Name of an existing EC2 key pair, which allows you to securely connect to
      your instance after it launches.
    Type: 'AWS::EC2::KeyPair::KeyName'
    ConstraintDescription: Required
  Subnet:
    Description: >-
      ID of private subnet 1 in Availability Zone 1 for the Pyramid
      Servers (e.g., subnet-a0246dcd).
    Type: 'AWS::EC2::Subnet::Id'
    ConstraintDescription: Required
  AssignPublicIP:
    Description: >-
      Assign public IP address and domain.
    Type: String
    Default: false
    AllowedValues:
      - true
      - false
    ConstraintDescription: Required
  InstanceType:
    Description: >-
      Amazon EC2 instance type for the Pyramid instances.
      Has to be available for the deployment region.
    Type: String
    AllowedValues:
      - m5.large
      - m5.xlarge
      - m5.2xlarge
      - m5.4xlarge
      - m5.8xlarge
      - m5.12xlarge
      - m5a.large
      - m5a.xlarge
      - m5a.2xlarge
      - m5a.4xlarge
      - m5a.8xlarge
      - m5a.12xlarge
      - m5n.large
      - m5n.xlarge
      - m5n.2xlarge
      - m5n.4xlarge
      - m5n.8xlarge
      - m5n.12xlarge
      - c5.large
      - c5.xlarge
      - c5.2xlarge
      - c5.4xlarge
      - c5.12xlarge
      - c5a.large
      - c5a.xlarge
      - c5a.2xlarge
      - c5a.4xlarge
      - c5a.8xlarge
      - c5a.12xlarge
      - c5n.large
      - c5n.xlarge
      - c5n.2xlarge
      - c5n.4xlarge
    Default: m5.xlarge
    MinLength: '1'
    ConstraintDescription: Must contain valid instance type.
  RepositoryType:
    Description: >-
      Creating or using a local or remote repository.
    Type: String
    AllowedValues:
      - currentremote
      - newremote
      - newlocal
    Default: currentremote
    MinLength: '1'
    ConstraintDescription: Must contain newremote, currentremote or newlocal.
  RDSUser:
    Description: Master user name for the RDS database.
    Type: String
    MinLength: '1'
    MaxLength: '64'
    AllowedPattern: '[-_a-zA-Z0-9]*'
    ConstraintDescription: It can contain only alphanumeric characters and underscores.
  RDSPassword:
    Description: >-
      Master password for the RDS database. Min 8 characters. Can contain only
      alphanumeric characters, minus and underscores.
    Type: String
    MinLength: '8'
    MaxLength: '64'
    NoEcho: 'true'
    AllowedPattern: '[-_a-zA-Z0-9]*'
    ConstraintDescription: >-
      Min 8 characters. Can contain only alphanumeric characters, minus and
      underscores.
  RDSAddress:
    Description: Domain/Address of the Amazon Postgres RDS database.
    Type: String
    MinLength: '1'
    MaxLength: '128'
    AllowedPattern: '[-_a-zA-Z0-9\.]*'
    ConstraintDescription: >-
      Domain/Address should be letters, digits, '.', '-' or underscores. Maximum
      128 characters long.
  RDSPort:
    Description: RDS Port
    Type: Number
    Default: '5432'
    MinValue: '1024'
    ConstraintDescription: Port number should be higher than 1024
  RDSName:
    Description: Repository database name.
    Type: String
    Default: pyramid
    MinLength: '1'
    MaxLength: '64'
    AllowedPattern: '[-_a-zA-Z0-9]*'
    ConstraintDescription: 'Can contain only alphanumeric characters, minus and underscores.'
  InitialUserPassword:
    AllowedPattern: "[a-zA-Z][a-zA-Z0-9]*"
    ConstraintDescription: "Min 8 characters. Must begin with a letter and contain only alphanumeric characters."
    Description: "The Pyramid initial user password."
    MaxLength: "64"
    MinLength: "8"
    NoEcho: "True"
    Type: String
  InitialUsername: 
    AllowedPattern: "[a-zA-Z][a-zA-Z0-9]*"
    ConstraintDescription: "Must begin with a letter and contain only alphanumeric characters."
    Default: admin
    Description: "The Pyramid initial username."
    MaxLength: "16"
    MinLength: "1"
    Type: String
  SharedFileSystemId: 
    AllowedPattern: "^$|[a-zA-Z][a-zA-Z0-9-]*"
    ConstraintDescription: "Must begin with a letter and contain only alphanumeric characters or minus."
    Default: ''
    Description: "EFS volume Id for existing file system shared across deployment."
    MaxLength: "32"
    Type: String
  IMDBFileSystemOption:
    Description: File system type for in-memory database persistence.
    Type: String
    Default: onInstance
    AllowedValues:
      - onInstance
      - existingExternal
      - newExternal
  # IMDBExternalFileSystemId: 
  #   AllowedPattern: "^$|[a-zA-Z][a-zA-Z0-9-]*"
  #   ConstraintDescription: "Must begin with a letter and contain only alphanumeric characters or minus."
  #   Default: ''
  #   Description: "EFS volume Id for in-memory database persistence for existing file system. Use if IMDBFileSystemOption != onInstance"
  #   MaxLength: "32"
  #   Type: String
Rules:
  KeyPairsNotEmpty:
    Assertions:
      - Assert: !Not 
          - 'Fn::EachMemberEquals':
              - 'Fn::RefAll': 'AWS::EC2::KeyPair::KeyName'
              - ''
        AssertDescription: All key pair parameters must not be empty
Conditions:
  CurrentRepositoryTypeCondition: !Equals
    - !Ref RepositoryType
    - currentremote
  TerminateInstance: !Equals
   - !Ref RunOnce
   - 'true'
  InstallNginx: !Equals
   - !Ref InstallProxy
   - 'true'
  AssignPublicIPCondition: !Equals
   - !Ref AssignPublicIP
   - 'true'
  DisableComponents: !Not
    - !Equals
      - !Ref PyramidProcess
      - 'Everything'
  IMDBProcessIncluded: !Or
    - !Equals
      - !Ref PyramidProcess
      - 'Everything'
    - !Equals
      - !Ref PyramidProcess
      - 'InMemoryDB'
  NotInternalIMDB: !And
    - !Condition IMDBProcessIncluded
    - !Not
      - !Equals
        - !Ref IMDBFileSystemOption
        - 'internal'
  InternalIMDB: !And
    - !Condition IMDBProcessIncluded
    - !Equals
      - !Ref IMDBFileSystemOption
      - 'internal'
  CreateExternalIMDB: !And
    - !Condition IMDBProcessIncluded
    - !Equals
      - !Ref IMDBFileSystemOption
      - 'newExternal'
Mappings:
  ProcessesToExclude:
    Processes:
      Router: 'linws,linrte,linte,linimdb,linai'
      WebServer: 'linrte,linte,linrtr,linimdb,linai'
      WebServerAndRouter: 'linrte,linte,linimdb,linai'
      RuntimeEngine: 'linws,linte,linrtr,linimdb,linai'
      TaskEngine: 'linws,linrte,linrtr,linimdb,linai'
      RuntimeEngineAndTaskEngine: 'linws,linrtr,linimdb,linai'
      RuntimeEngineAndAI: 'linws,linte,linrtr,linimdb'
      TaskEngineAndAI: 'linws,linrte,linrtr,linimdb'
      RuntimeAndTaskEngineAndAI: 'linws,linrtr,linimdb'
      AIServer: 'linws,linrte,linte,linrtr,linimdb'
      InMemoryDB: 'linws,linrte,linte,linrtr,linai'
      Nothing: 'linws,linrte,linte,linrtr,linimdb,linai'
      Everything: ''

Resources:
  InstanceWaitHandle:
    Type: 'AWS::CloudFormation::WaitConditionHandle'
  InstanceWaitCondition:
    Type: 'AWS::CloudFormation::WaitCondition'
    Properties:
      Handle: !Ref InstanceWaitHandle
      # 30 mins
      Timeout: '1800'
      Count: 1

  PyramidInstance:
    Type: 'AWS::EC2::Instance'
    Metadata:
      'AWS::CloudFormation::Init':
        configSets:
          default:
            - EnableAmazonLinuxExtraPackages
            - 01_setupCfnHup
            - 02_config-amazon-cloudwatch-agent
            - 03_restart_amazon-cloudwatch-agent
            - InstallPyramid
            - !If
              - InstallNginx
              - InstallNginx
              - !Ref 'AWS::NoValue'
          UpdateEnvironment:
            - 02_config-amazon-cloudwatch-agent
            - 03_restart_amazon-cloudwatch-agent

        EnableAmazonLinuxExtraPackages:
          packages:
            yum:
              amazon-efs-utils: []
              amazon-cloudwatch-agent: []
          commands:
            enable_nginx_R_EPEL:
              command: "amazon-linux-extras enable nginx1 R3.4 epel postgresql10 && yum clean metadata"

        # Cfn-hup setting, it is to monitor the change of metadata.
        # When there is change in the contents of json file in the metadata section, cfn-hup will call cfn-init to restart the AmazonCloudWatchAgent.
        01_setupCfnHup:
          files:
            '/etc/cfn/cfn-hup.conf':
              content: !Sub |
                [main]
                stack=${AWS::StackId}
                region=${AWS::Region}
                interval=1
              mode: '000400'
              owner: root
              group: root
            '/etc/cfn/hooks.d/amazon-cloudwatch-agent-auto-reloader.conf':
              content: !Sub |
                [cfn-auto-reloader-hook]
                triggers=post.update
                path=Resources.PyramidInstance.Metadata.AWS::CloudFormation::Init.02_config-amazon-cloudwatch-agent
                action=/opt/aws/bin/cfn-init -v --stack ${AWS::StackId} --resource PyramidInstance --region ${AWS::Region} --configsets UpdateEnvironment
                runas=root
              mode: '000400'
              owner: root
              group: root
            "/lib/systemd/system/cfn-hup.service":
              content: |
                [Unit]
                Description=cfn-hup daemon
                [Service]
                Type=simple
                ExecStart=/opt/aws/bin/cfn-hup
                Restart=always
                [Install]
                WantedBy=multi-user.target
          commands:
            01enable_cfn_hup:
              command: systemctl enable cfn-hup.service
            02start_cfn_hup:
              command: systemctl start cfn-hup.service

        # Definition of json configuration of AmazonCloudWatchAgent
        02_config-amazon-cloudwatch-agent:
          files:
            /opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json:
              content: !Sub |
                {
                  "logs": {
                    "logs_collected": {
                      "files": {
                        "collect_list": [
                          {
                            "file_path": "/var/log/cfn-init.log",
                            "log_group_name": "/pyramid/${BaseStackName}",
                            "log_stream_name": "{instance_id}-${InstancePurpose}/cf-init",
                            "timestamp_format": "%Y-%m-%d %H:%M:%S,%f"
                          },
                          {
                            "file_path": "/var/log/cfn-init-output.log",
                            "log_group_name": "/pyramid/${BaseStackName}",
                            "log_stream_name": "{instance_id}-${InstancePurpose}/cf-init-output",
                            "timestamp_format": "%Y-%m-%d %H:%M:%S,%f"
                          },
                          {
                            "file_path": "/var/log/cloud-*.log",
                            "log_group_name": "/pyramid/${BaseStackName}",
                            "log_stream_name": "{instance_id}-${InstancePurpose}/cloud-init",
                            "timestamp_format": "%Y-%m-%d %H:%M:%S,%f"
                          },
                           {
                            "file_path": "/tmp/*.log",
                            "log_group_name": "/pyramid/${BaseStackName}",
                            "log_stream_name": "{instance_id}-${InstancePurpose}/installers",
                            "timestamp_format": "%Y-%m-%d %H:%M:%S,%f"
                          },
                          {
                            "file_path": "/opt/Pyramid/log/*.log",
                            "log_group_name": "/pyramid/${BaseStackName}",
                            "log_stream_name": "{instance_id}-${InstancePurpose}/pyramid-logs",
                            "timestamp_format": "%Y-%m-%d %H:%M:%S,%f"
                          }
                        ]
                      }
                    }
                  }
                }
        # Invoke amazon-cloudwatch-agent-ctl to restart the AmazonCloudWatchAgent.
        03_restart_amazon-cloudwatch-agent:
          commands:
            01_stop_service:
              command: /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a stop
            02_start_service:
              command: /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -c file:/opt/aws/amazon-cloudwatch-agent/etc/amazon-cloudwatch-agent.json -s

        InstallPyramid:
          packages:
            yum:
              # installed with EFS
              # nfs-utils: []
              postgresql: []
              
          files:
            /usr/src/pyramid/mnt-efs.sh:
              content: |
                #!/bin/bash
                #
                # Set up an EFS mount on an instance.
                #
                # Create the mount target if one has not been created for
                # the AZ the subnet is attached to.
                # 
                # Create the  --mountPoint <mount point directory> and mount an Elastic File
                # System (EFS) id --efsId <EFS ID> to it.
                #
                # Parameters:
                # efsId=${efsId}
                # mountPoint=${mountPoint:-/mnt/pyramid}
                # efsRootDirectory=${efsRootDirectory:-/}
                # ownership=${ownership:-pyramid:pyramid}
                # subnet
                # securityGroup
                # region
                #
                # So minimal use is:
                # mnt-efs.sh \
                #   --efsId fs-24334234 \
                #   --subnet subnet-055fb67972f8052d2 \
                #   --securityGroup sg-0667a5ea299a0e03c \
                #   --region us-east-1
                ##
                # This script can only run on an AWS instance. It must run as root, and be
                # invoked at instance startup: cf-init, user data
                #
                
                set -o errexit

                # ----------------------------------------------------------------------------
                # Set and validate parameters
                # ----------------------------------------------------------------------------

                efsId=${efsId}
                efsRootDirectory=${efsRootDirectory:-/}
                mountPoint=${mountPoint:-/mnt/pyramid}
                ownership=${ownership:-pyramid:pyramid}
                subnet=
                securityGroup=
                region=

                wait_for_mount_target_availability() {
                  local mountTarget=${1}
                  local region=${2}

                  echo "Waiting for mount target $mountTarget to be available"
                  local maxTimes=30
                  local sleepTime=10
                  local count=0
                  local notificationCount=5
                  while true
                  do
                    describeMT=`aws efs describe-mount-targets --mount-target-id $mountTarget --region $region --output text`
                    mt_status=$( echo "$describeMT" | cut -f 6 )
                    if [ "${mt_status}" = "available" ] ; then
                      break
                    fi
                    count=$(( count + 1  ))
                    if [ "$count" -ge "$maxTimes" ] ; then
                      echo "Mount target status is $mt_status. Did not become available after ${maxTimes} tries, waiting ${sleepTime} seconds between tries... Exiting"
                      return 1
                    elif  ! (( count % notificationCount )) ; then
                      echo "Mount target status is $mt_status ...continuing to wait"
                    fi
                    sleep $sleepTime
                  done
                  echo "Mount target $mountTarget is available"
                  return 0
                }

                create_mount_target() {
                  local efsId=${1}
                  local subnet=${2}
                  local securityGroup=${3}
                  local region=${4}

                  # Subnet AZ
                  subnetAZ=`aws ec2 describe-subnets --subnet-ids $subnet --region $region --output text | grep '^SUBNETS' | cut -f 3` || return 1
                  local foundAZ=1

                  allMountTargets=`aws efs describe-mount-targets --file-system-id $efsId --region $region --output text`
                  if [ $? -ne 0 ] ; then
                    return 1
                  fi
                  while read line ; do
                    az=$( echo "$line" | cut -f 3 )
                    mt_status=$( echo "$line" | cut -f 6 )
                    mountTarget=$( echo "$line" | cut -f 7 )
                    if [ "${az}" = "${subnetAZ}" ] ; then
                      if [ "${mt_status}" != 'available' ] ; then
                        wait_for_mount_target_availability $mountTarget $region
                        if [ $? -ne 0 ] ; then
                          return 1
                        fi
                      fi
                      foundAZ=0
                      break
                    fi
                  done <<< "$allMountTargets"

                  if [ $foundAZ = 0 ]; then
                    echo "Mount target for $efsId in $subnetAZ already existed"
                    return 0
                  fi
                  echo "About to create mount target for file system: $efsId in AZ: $subnetAZ"
                  newMountTargetResult=`aws efs create-mount-target \
                      --file-system-id $efsId \
                      --subnet-id $subnet \
                      --security-groups $securityGroup \
                      --region $region \
                      --output text`
                  if [ $? -ne 0 ] ; then
                    echo "create-mount-target failed"
                    return 1
                  fi
                  mt_id=$( echo "$newMountTargetResult" | cut -f 6 )

                  wait_for_mount_target_availability $mt_id $region
                  return $?
                }

                mount_efs() {
                  local efsId=${1}
                  local mountPoint=${2}
                  local efsRootDirectory=${3:-/}
                  local ownership=${4:"pyramid:pyramid"}

                  # ----------------------------------------------------------------------------
                  # Create mount point directory
                  # ----------------------------------------------------------------------------
                  # if the mountPoint directory does not exist
                  if [ ! -d "${mountPoint}" ] ; then
                    mkdir -p "${mountPoint}"
                    chown "${ownership}" "${mountPoint}"
                  else
                    # fail if the mountPoint already exists
                    echo "mountPoint directory ${mountPoint} already exists. exiting..."
                    exit 1
                  fi

                  # Mount the EFS volume using the AWS EFS helper
                  # IAM is used for authentication to EFS
                  local sleepTime=20
                  local maxTimes=40
                  local notificationCount=5
                  local count=0
                  while true
                  do
                    mount -t efs -o tls,iam $efsId:$efsRootDirectory $mountPoint && break
                    count=$(( count + 1  ))
                    if [ "$count" -ge "$maxTimes" ] ; then
                      echo "Mount did not succeed after ${maxTimes} tries, waiting ${sleepTime} seconds between tries... Exiting"
                      exit 1
                    elif  ! (( count % notificationCount )) ; then
                        echo "Mount did not succeed ...continuing to wait"
                    fi
                    sleep $sleepTime
                  done
                }

                ##########################################
                # main script

                while [ $# -gt 0 ]; do
                  if [[ $1 == *"--"* ]]; then
                    param="${1/--/}"
                    declare $param="$2"
                    echo $1 $2 # Optional: to see the parameter:value result
                    shift
                  fi
                  shift
                done

                if [[ -z "${efsId}" ]] ; then
                  echo "efsId not set"
                  exit 1
                fi

                if [[ -z "${subnet}" ]] ; then
                  echo "subnet not set"
                  exit 1
                fi

                if [[ -z "${securityGroup}" ]] ; then
                  echo "securityGroup not set"
                  exit 1
                fi

                if [[ -z "${region}" ]] ; then
                  echo "region not set"
                  exit 1
                fi
                

                # create a mount target group if needed
                create_mount_target $efsId $subnet $securityGroup $region
                if [ $? -ne 0 ] ; then
                echo "create_mount_target failed"
                exit 1
                fi

                if [[ "$efsRootDirectory" != "/" ]] ; then
                  echo "Making sure $efsId:$efsRootDirectory exists"

                  tmpMountPoint="/tmp${mountPoint}"
                  mount_efs $efsId $tmpMountPoint

                  if [ ! -d "${tmpMountPoint}${efsRootDirectory}" ] ; then
                    mkdir -p "${tmpMountPoint}${efsRootDirectory}"
                    chown pyramid:pyramid "${tmpMountPoint}${efsRootDirectory}"
                  fi

                  umount $tmpMountPoint
                  rm -rf $tmpMountPoint
                fi 

                echo "About to mount $efsId:$efsRootDirectory to $mountPoint"

                mount_efs $efsId $mountPoint $efsRootDirectory

                echo "Mounted EFS $efsId:$efsRootDirectory to $mountPoint"

              mode: '000755'
              owner: root
              group: root

            /usr/src/pyramid/mnt-imdb.sh:
              content: |
                #!/bin/bash
                #
                # After installation of an IMDB, move the IMDB files to a
                # directory on the shared EFS volume.
                #
                # Parameters:
                # mountPoint=${mountPoint:-/mnt/pyramid-imdb}
                # installLocation=${installLocation:-/opt/Pyramid}
                # dataLocation=${dataLocation:-/opt/Pyramid/repository}
                # baseStackName=
                # currentStackName=

                #
                # This script can only run on an AWS instance with Pyramid already installed.
                #
                set -o errexit

                # ----------------------------------------------------------------------------
                # Set and validate parameters
                # ----------------------------------------------------------------------------

                mountPoint=${mountPoint:-/mnt/pyramid-imdb}
                installLocation=${installLocation:-/opt/Pyramid}
                dataLocation=${dataLocation:-/opt/Pyramid/repository}
                baseStackName=
                currentStackName=
                initialize=${initialize:-false}
                ##########################################
                # main script

                while [ $# -gt 0 ]; do
                  if [[ $1 == *"--"* ]]; then
                    param="${1/--/}"
                    declare $param="$2"
                    echo $1 $2 # Optional: to see the parameter:value result
                    shift
                  fi
                  shift
                done

                if [[ -z "${mountPoint}" ]] ; then
                  echo "mountPoint not set"
                  exit 1
                fi

                if [[ -z "${efsId}" ]] ; then
                  echo "efsId not set"
                  exit 1
                fi

                if [[ -z "${securityGroup}" ]] ; then
                  echo "securityGroup not set"
                  exit 1
                fi

                if [[ -z "${installLocation}" ]] ; then
                  echo "installLocation not set"
                  exit 1
                fi

                if [[ -z "${dataLocation}" ]] ; then
                  echo "dataLocation not set"
                  exit 1
                fi

                if [[ -z "${baseStackName}" ]] ; then
                  echo "baseStackName not set"
                  exit 1
                fi

                if [[ -z "${currentStackName}" ]] ; then
                  echo "currentStackName not set"
                  exit 1
                fi

                if [[ ! -f "${installLocation}/config.ini" ]] ; then
                  echo "Pyramid config.ini in ${installLocation} does not exist. exiting..."
                  exit 1
                fi
                if [[ ! -d "${dataLocation}" ]] ; then
                  echo "Pyramid data-location directory ${dataLocation} does not exist. exiting..."
                  exit 1
                fi

                # Single EFS volume now
                # /mnt/pyramid
                #   /imdb/<id>
                #     individual imdata directories
                #     current list in ssm baseStack/stack/IMDBFileSystem = <id> vs list of imdb/<id>
                #     if list of imdb/<id> is longer than baseStack/stack/IMDBFileSystem
                #       use next imdb/<id> -> baseStack/stack/IMDBFileSystem
                #     else
                #       create new imdb/<id>
                #     fs:imdb/<id> to /mnt/pyramid-imdb

                tempMountPoint="/tmp${mountPoint}"
                echo "mounting efs/imdb to /tmp to check what is there"
                /usr/src/pyramid/mnt-efs.sh \
                  --mountPoint $tempMountPoint \
                  --subnet $subnet \
                  --securityGroup $securityGroup \
                  --efsId $efsId \
                  --region $region

                if [ ! -d $tempMountPoint/imdb ] ; then 
                  mkdir $tempMountPoint/imdb
                  chown pyramid:pyramid $tempMountPoint/imdb
                fi 
                EFSImdbGUIDs=( $(ls -l $tempMountPoint/imdb | grep '^d' | cut -d " " -f 9) )

                echo "Current IMDBs in EFS: ${EFSImdbGUIDs}"

                # what IMDBs have we already configured for this deployment?

                currentDeploymentImdbGUIDs=()

                ssmParams=`aws ssm get-parameters-by-path --path "/Pyramid/$baseStackName" --recursive --region $region --output text`
                # looking for SSM parameters of the forms:
                #    '/Pyramid/$baseStackName/${AWS::StackName}/IMDBFileSystem'

                while read line ; do
                  name=`echo $line | cut -d " " -f 5`
                  endPortion=`echo $name | cut -d '/' -f 5`

                  # echo "<$name> **** <$endPortion>"
                  if [[ "${endPortion}" = "IMDBFileSystem" ]] ; then
                    fileSystemGUID=`echo $line | cut -d " " -f 7`
                    currentDeploymentImdbGUIDs+=$fileSystemGUID
                  fi
                done <<< "$ssmParams"

                echo "Current IMDBs deployed against instances: ${EFSImdbGUIDs}"

                for target in "${currentDeploymentImdbGUIDs[@]}"; do
                  for i in "${!EFSImdbGUIDs[@]}"; do
                    if [[ ${EFSImdbGUIDs[i]} = $target ]]; then
                      unset 'EFSImdbGUIDs[i]'
                    fi
                  done
                done

                echo "Not yet deployed IMDBs in EFS: ${EFSImdbGUIDs}"

                EFSImdbGUIDsSize=${#EFSImdbGUIDs[@]}
                echo "Number of Not yet deployed IMDBs in EFS: ${EFSImdbGUIDsSize}"

                if [[ $EFSImdbGUIDsSize > 0 ]] ; then 
                  GUIDToDeploy=${EFSImdbGUIDs[0]}
                  echo "Using existing GUID directory for IMDB: $GUIDToDeploy. Containing:"
                  ls -l $tempMountPoint/imdb/$GUIDToDeploy
                  initialize=false
                else
                  GUIDToDeploy=`date +"%Y-%m-%d-%H-%m-%s%z"`
                  echo "creating GUID directory for new IMDB: $GUIDToDeploy"
                  mkdir $tempMountPoint/imdb/$GUIDToDeploy
                  chown pyramid:pyramid $tempMountPoint/imdb/$GUIDToDeploy
                fi

                umount $tempMountPoint
                rm -rf $tempMountPoint

                echo "mounting $efsId:/imdb/$GUIDToDeploy to $mountPoint"
                /usr/src/pyramid/mnt-efs.sh \
                  --mountPoint $mountPoint \
                  --subnet $subnet \
                  --securityGroup $securityGroup \
                  --efsId $efsId \
                  --efsRootDirectory /imdb/$GUIDToDeploy \
                  --region $region

                # Stop the IMDB service
                systemctl stop pyramidIMDB

                # we are going to mount imdata at ${dataLocation}

                # If new, Copy current imdata into the EFS volume 
                # if [[ $newGUID && "$(ls -A ${dataLocation}/imdata)" ]] ; then
                if [[ "${initialize}" == "true" ]] ; then
                  cp -p -R $dataLocation/imdata/. $mountPoint
                  echo "Initialized IMDB files with on-instance IMDATA"
                fi

                # Update the config.ini reference for the IMDB datadirlocal= to the mountPoint
                sed -i "s|datadirlocal=.*|datadirlocal=$mountPoint|" "$installLocation/config.ini"

                echo "IMDB files at $mountPoint are:"
                ls -l $mountPoint

                # Restart the IMDB service
                systemctl start pyramidIMDB

                # create SSM param 
                aws ssm put-parameter \
                  --name "/Pyramid/$baseStackName/$currentStackName/IMDBFileSystemId" \
                  --type String \
                  --value $GUIDToDeploy \
                  --overwrite \
                  --region $region


              mode: '000755'
              owner: root
              group: root

            /usr/src/pyramid/restore-from-s3:
              content: |
                #!/bin/bash
                baseStackName=${1}
                bucketAndFolder=${2}
                subnet=${3}
                mtSecurityGroup=${4}
                sharedFileSystemEFS=${5}
                rdsAddress=${6}
                rdsPort=${7}
                rdsUsername=${8}
                rdsPassword=${9}
                rdsName=${10}
                region=${11}
                clearOldServers=${12:-true}

                set -o errexit

                /usr/src/pyramid/mnt-efs.sh \
                    --mountPoint /mnt/pyramid-backup \
                    --subnet $subnet \
                    --securityGroup $mtSecurityGroup \
                    --efsId $sharedFileSystemEFS \
                    --region $region

                echo "Synching backup in s3://$bucketAndFolder to EFS $sharedFileSystemEFS"
                # dump s3 into the shared file system
                aws s3 sync --no-progress s3://$bucketAndFolder/ /mnt/pyramid-backup

                if [ ! -d /mnt/pyramid-backup/repoBackup ] ; then
                  echo "No /mnt/pyramid-backup/repoBackup directory. Exiting..."
                  exit 1
                fi

                # get the latest dump file
                dumpFile=`ls -t1 /mnt/pyramid-backup/repoBackup/*.dump |  tail -n 1`

                if [[ -z "${dumpFile}" ]] ; then
                  echo "No *.dump files in /mnt/pyramid-backup/repoBackup directory. Exiting..."
                  exit 1
                fi

                echo "restoring $dumpFile to database $rdsName on service $rdsAddress"

                # create a new database and restore the repository dump into it
                export PGPASSWORD=$rdsPassword
                createdb -U $rdsUsername -h $rdsAddress -p $rdsPort $rdsName

                # exclude extensions
                pg_restore -l -F c -U $rdsUsername -h $rdsAddress -p $rdsPort $dumpFile | grep -v "EXTENSION" > /tmp/ignore_pg_extensions

                # Compressed. No Owner. No privileges
                pg_restore -F c -O -x -L /tmp/ignore_pg_extensions -U $rdsUsername -h $rdsAddress -p $rdsPort -d $rdsName $dumpFile

                if [ "${clearOldServers}" == "true" ] ; then
                  echo "Deleting server_instances"
                  psql -U $rdsUsername -h $rdsAddress -p $rdsPort -d $rdsName <<EOF
                delete from server_instances;
                EOF
                fi

                umount /mnt/pyramid-backup
                rm -rf /mnt/pyramid-backup

              mode: '000755'
              owner: root
              group: root

            /usr/src/pyramid/pyramid-unattended-install.ini:
              content: !Join 
                - ''
                - - install-location=/opt/Pyramid
                  - |+

                  - data-location=/opt/Pyramid/repository
                  - |+

                  - installation-type=1
                  - |+

                  - !If
                    - DisableComponents
                    - !Join
                      - ''
                      - - disable-components=
                        - !FindInMap 
                          - ProcessesToExclude
                          - Processes
                          - !Ref PyramidProcess
                    - ''
                  - |+

                  - repositoryChoice=
                  - !Ref RepositoryType
                  - |+

                  - !If
                    - CurrentRepositoryTypeCondition
                    - selectCurrentRepository=0
                    - selectNewRepository=0
                  - |+

                  - postgreSqlHost=
                  - !Ref RDSAddress
                  - |+

                  - postgreSqlPort=
                  - !Ref RDSPort
                  - |+

                  - postgreSqlDb=
                  - !Ref RDSName
                  - |+

                  - postgreSqlUsername=
                  - !Ref RDSUser
                  - |+

                  - postgreSqlUserPassword=
                  - !Ref RDSPassword
                  - |+

                  - initUserName=
                  - !Ref InitialUsername
                  - |+

                  - initUserPassword=
                  - !Ref InitialUserPassword
                  - |+

                  - ''

              encoding: plain
              mode: '000644'
          commands:

# Single EFS volume now
# /mnt/pyramid

#   shared/
  #   common file system
  #   fs:/shared to /mnt/pyramid
  #   create fs:/shared if it does not exist

#   imdb/<id>
#     individual imdata directories
#     current list in ssm baseStack/stack/IMDBFileSystem = <id> vs list of imdb/<id>
#     if list of imdb/<id> is longer than baseStack/stack/IMDBFileSystem
#       use next imdb/<id> -> baseStack/stack/IMDBFileSystem
#     else
#       create new imdb/<id>
#     fs:imdb/<id> to /mnt/pyramid-imdb

#   repoBackup/$baseStackName-repository-$timestamp.dump
#     backups
#     ignore these in Pyramid instances

            0-update-chrome dependencies:
              command: yum update nss -y
              ignoreErrors: 'false'
            1-execute-restore:
              test: !Join
                - ''
                - - '[ -n "'
                  - !Ref BackupS3BucketAndFolder
                  - '" ]'
              # restore-from-s3 \
              #   Pyr-v8 \
              #   pyr-v8-backup-s3bucket-17f7k5buabvbh/2020-11-11-08-50-14
              #   subnet-01892aa0ff74872e0 \
              #   sg-0ecfc9a157ede67dd \
              #   fs-ec548f19 \
              #   pyr-v8.cluster-cfave2vnma46.us-east-1.rds.amazonaws.com
              #   5432
              #   aName
              #   aPassword
              #   aDatabaseName
              #   us-east-1 \
              #   true
              command: !Join
                - ' '
                - - /usr/src/pyramid/restore-from-s3
                  - !Ref BaseStackName
                  - !Ref BackupS3BucketAndFolder
                  - !Ref Subnet
                  - !Ref MountTargetSecurityGroup
                  - !Ref SharedFileSystemId
                  - !Ref RDSAddress
                  - !Ref RDSPort
                  - !Ref RDSUser
                  - !Ref RDSPassword
                  - !Ref RDSName
                  - !Sub '${AWS::Region}'
                  - true
              ignoreErrors: 'false'
            2-install:
              cwd: /usr/src/pyramid
              command: "for i in Pyramid*.run; do /usr/src/pyramid/$i --mode unattended --optionfile /usr/src/pyramid/pyramid-unattended-install.ini; done"
              ignoreErrors: 'false'
            3-cleanup:
              command: "rm /usr/src/pyramid/pyramid-unattended-install.ini && rm -f /tmp/pyr*.log && rm -f /tmp/bit*.log"
              ignoreErrors: 'false'
            4-mount-shared-fs:
              command: !Join
                - ' '
                - - '/usr/src/pyramid/mnt-efs.sh --mountPoint /mnt/pyramid --subnet'
                  -  !Ref Subnet
                  - '--securityGroup'
                  - !Ref MountTargetSecurityGroup
                  - '--efsId'
                  - !Ref SharedFileSystemId
                  - '--efsRootDirectory /shared'
                  - '--region'
                  - !Ref AWS::Region
              ignoreErrors: 'false'
            5-mount-IMDB-fs:
              test: !Join
                - ''
                - - '[[ ''Everything,InMemoryDB'' == *"'
                  - !Ref PyramidProcess
                  - '"* && '''
                  - !Ref IMDBFileSystemOption
                  - ''' != ''onInstance'' ]]'
              command: !Join
                - ' '
                - - "/usr/src/pyramid/mnt-imdb.sh --mountPoint /mnt/pyramid-imdb"
                  - "--baseStackName"
                  - !Ref BaseStackName
                  - "--currentStackName"
                  - !Ref 'AWS::StackName'
                  - "--subnet"
                  - !Ref Subnet
                  - "--securityGroup"
                  - !Ref MountTargetSecurityGroup
                  - "--efsId"
                  - !Ref SharedFileSystemId
                  - "--region"
                  - !Ref 'AWS::Region'
                  - "--initialize"
                  - !If
                    - CurrentRepositoryTypeCondition
                    - false
                    - true
              ignoreErrors: 'false'

        InstallNginx:
          packages:
            yum:
              nginx: []
          files:
            /etc/nginx/default.d/proxy.conf:
              content: |
                location / {
                  proxy_pass http://127.0.0.1:8181;
                }
                location /events {
                  proxy_pass http://127.0.0.1:8181/events;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection "upgrade";
                }
              mode: '000755'
              owner: root
              group: root

          services:
            sysvinit:
              nginx:
                enabled: true
                ensureRunning: true
                files:
                  - /etc/nginx/default.d/proxy.conf
    Properties:
      ImageId: !Ref AMIID
      KeyName: !Ref KeyPairName
      IamInstanceProfile: !Ref PyramidInstanceProfile
      InstanceType: !Ref InstanceType
      SecurityGroupIds: !If
        - AssignPublicIPCondition
        - !Ref 'AWS::NoValue'
        - !Ref WorkloadSecurityGroups
      SubnetId: !If
        - AssignPublicIPCondition
        - !Ref 'AWS::NoValue'
        - !Ref Subnet
      InstanceInitiatedShutdownBehavior: !If
        - TerminateInstance
        - terminate
        - stop
      Monitoring: false
      DisableApiTermination: false
      BlockDeviceMappings:
        - DeviceName: "/dev/sda1"
          Ebs: 
            VolumeSize: 20
      NetworkInterfaces: !If
        - AssignPublicIPCondition
        - -
            AssociatePublicIpAddress: true
            DeleteOnTermination: true
            DeviceIndex: '0'
            GroupSet: !Ref WorkloadSecurityGroups
            SubnetId: !Ref Subnet
        - !Ref 'AWS::NoValue'
      UserData: !Base64
        'Fn::Join':
          - ''
          - - |
              Content-Type: multipart/mixed; boundary="//"
              MIME-Version: 1.0
              --//
              Content-Type: text/cloud-config; charset="us-ascii"
              MIME-Version: 1.0
              Content-Transfer-Encoding: 7bit
              Content-Disposition: attachment; filename="cloud-config.txt"
              #cloud-config
              cloud_final_modules:
              [scripts-user, always]
              --//
              Content-Type: text/x-shellscript; charset="us-ascii"
              MIME-Version: 1.0
              Content-Transfer-Encoding: 7bit
              Content-Disposition: attachment; filename="userdata.txt"
              #!/bin/bash -xe

              # run cfn-init

            - '/opt/aws/bin/cfn-init -v  --configsets default --stack '
            - !Ref 'AWS::StackName'
            - ' --resource PyramidInstance --region '
            - !Ref 'AWS::Region'
            - |+

            - |
              # Signal the status from cfn-init

            - '/opt/aws/bin/cfn-signal -e $? '
            - !Base64
              Ref: InstanceWaitHandle
            - |+

            - |
              # If asked, halt and catch fire

            - 'if [ '''
            - !Ref RunOnce
            - ''' = ''true'' ] ; then /sbin/halt -p; fi'
            - |+

            - ''
            - |+

      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}'
        - Key: Vendor
          Value: Pyramid
        - Key: StackName
          Value: !Sub '${BaseStackName}'
        - Key: Contents
          Value: !Sub '${InstancePurpose}'

Outputs:
  RDSAddress:
    Description: Database domain name
    Value: !Ref RDSAddress
  PyramidRDSName:
    Description: Pyramid database name
    Value: !Ref RDSName
  InitialUsername:
    Value: !Ref InitialUsername
    Description: Initial user name
  InitialPassword:
    Value: !Ref InitialUserPassword
    Description: Initial user password
  PublicDNSName:
    Value: !GetAtt PyramidInstance.PublicDnsName
    Description: Instance Public DNS name
  PrivateDNSName:
    Value: !GetAtt PyramidInstance.PrivateDnsName
    Description: Instance Private DNS name
  # IMDBFileSystem:
  #   Value: !If
  #     - IMDBProcessIncluded
  #     - !If
  #       - CreateExternalIMDB
  #       - !Ref IMDBFileSystem
  #       - !If
  #         - InternalIMDB
  #         - Internal
  #         - !Ref IMDBExternalFileSystemId
  #     - 'No In-memory database file system created'
  #   Description: EFS file system for the In-Memory database

